**什么是MQ**

MQ(Message Queue)即消息队列，通过典型的生产者和消费者模型，生产者不断向消息队列中生产消息，消费者不断从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，轻松的实现系统间解耦，别名为消息中间件，通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。

**MQ有哪些**

当前市面上有很多主流的消息中间件，如老牌的ActiveMQ、rabbitMQ、炙手可热的Kafka、阿里巴巴自主开发的RocketMQ等。

**AMQP协议**

AMQP(Advanced message queuing protocol),在2003年时被提出，最早用于解决金融领域不同平台之间的信息传递交互问题，顾名思义，AMQP是一种协议，更准确的说是一种binary wirelevel protocol(链接协议)，这是其和JMS的本质区别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式，这使得实现了AMQP的provider天然就是跨平台的，以下是AMQP协议模型：

![](../%E5%B7%A5%E5%85%B7/rabbitMQ_1.png)

https://github.com/1063545557/java/blob/main/img/rabbitMQ_1.png?raw=true

![](../%E5%B7%A5%E5%85%B7/rabbitMQ_2-1612585199726.png)

https://github.com/1063545557/java/blob/main/img/rabbitMQ_2.png?raw=true

基本概念说明：

**Broker**：简单来说就是消息队列服务器实体。
　　**Exchange**：消息交换机，它指定消息按什么规则，路由到哪个队列。
　　**Queue**：消息队列载体，每个消息都会被投入到一个或多个队列。
　　**Binding**：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。
　　**Routing Key**：路由关键字，exchange根据这个关键字进行消息投递。
　　**vhost**：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。
　　**producer**：消息生产者，就是投递消息的程序。
　　**consumer**：消息消费者，就是接受消息的程序。
　　**channel**：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。

消息队列的使用过程大概如下：

　　（1）客户端连接到消息队列服务器，打开一个channel。
　　（2）客户端声明一个exchange，并设置相关属性。
　　（3）客户端声明一个queue，并设置相关属性。
　　（4）客户端使用routing key，在exchange和queue之间建立好绑定关系。
　　（5）客户端投递消息到exchange。

exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。

exchange也有几个类型，完全根据key进行投递的叫做Direct交换机，例如，绑定时设置了routing key为”abc”，那么客户端提交的消息，只有设置了key为”abc”的才会投递到队列。对key进行模式匹配后进行投递的叫做Topic交换机，符号”#”匹配一个或多个词，符号”*”匹配正好一个词。例如”abc.#”匹配”abc.def.ghi”，”abc.*”只匹配”abc.def”。还有一种不需要key的，叫做Fanout交换机，它采取广播模式，一个消息进来时，投递到与该交换机绑定的所有队列。

RabbitMQ支持消息的持久化，也就是数据写在磁盘上，为了数据安全考虑，我想大多数用户都会选择持久化。消息队列持久化包括3个部分：
　　（1）exchange持久化，在声明时指定durable => 1
　　（2）queue持久化，在声明时指定durable => 1
　　（3）消息持久化，在投递时指定delivery_mode => 2（1是非持久化）

如果exchange和queue都是持久化的，那么它们之间的binding也是持久化的。如果exchange和queue两者之间有一个持久化，一个非持久化，就不允许建立绑定。

五种模型

### springboot整合RabbitMQ

1. 引入依赖

```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

2. 配置配置文件

```java
spring:
	application:
		name: springboot_rabbitmq
    rabbitmq:
		host: 192.168.3.212
        port: 5672
        username: ems
        password: 123
        virtual-host: /ems
```

3. 5种模型的使用

### MQ的应用场景

#### 1. 异步处理

用户注册后，需要发注册邮件和注册短信，传统的做法有两种 1. 串行的方式 2.并行的方式

**串行方式：**将注册信息写入数据库后，发送注册邮件，再发送注册短信，以上三个任务全部完成后才会返回给客户端。这有一个问题是，邮件，短信并不是必须的，他只是一个通知，而这种做法让客户端等待没有必要等待的东西。

**并行方式：**将注册信息写入数据库后，发送邮件的同时，发送短信，以上三个任务完成后，返回给客户端，并行的方式能提高处理的时间。

**消息队列：**假设三个业务节点分别使用50ms，串行方式使用时间150ms,并行使用时间100ms.虽然并行已经提高了处理时间，但是，前面说过，邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功，应该是写入数据库后就返回。消息队列：引入消息队列后，把发送邮件，短信不是必须的业务逻辑异步处理

引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间（可以忽略不计），引入消息队列处理后，响应时间是串行的三倍，是并行的两倍。

#### 2. 应用解耦

场景：双11是购物狂节，用户下单后，订单系统需要通知库存系统，传统的做法就是订单系统调用库存系统的接口。

这种做法有一个缺点：当库存系统出现故障时，订单就会失败。订单系统和库存系统高耦合，引入消息队列

订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功

库存系统：订阅下单的消息，获取下单消息，进行库操作。就算库存系统出现故障，消息队列也能保证消息的可靠投递，不会导致消息丢失。

#### 3.流量削峰

场景：秒杀活动，一般会因为流量过大，导致应用挂掉，为了解决这个问题，一般在应用前端加入消息队列

作用：1.可以控制活动人数，超过此一定阈值的订单直接丢弃.2.可以缓解短时间的高流量压垮应用

1.用户的请求，服务器收到之后，首先写入消息队列，加入消息队列长度超过最大值，则直接抛弃用户请求或跳转到错误页面

2.秒杀业务根据消息队列中的请求信息，再做后续处理

### RabbitMQ集群

#### 集群架构

**普通集群（副本集群）**

默认情况下：RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是消息队列，默认情况下，消息队列位于一个节点上，尽管他们可以从所有节点看到和访问

![](../%E5%B7%A5%E5%85%B7/rabbitMQ_3.png)

核心解决问题：当集群中某一时刻master节点宕机，可以对Queue中信息进行备份

**镜像集群**

镜像队列机制就是跨队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性

![](../%E5%B7%A5%E5%85%B7/rabbitMQ_4.png)

